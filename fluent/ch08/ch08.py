
# オブジェクト参照、可変性、リサイクル

# オブジェクトは作成されたあとでのみ変数に代入される。
class Gizmo:

    def __init__(self):
        print("Gizmo id: %d" % id(self))

# Gizmoインスタンスを作成すると、その副作用でGzmo is ... が出力される
x = Gizmo()

# Gizmoインスタンスを定数倍すると例外が発生する
# ここからGizmoは乗算を試みる前にインスタンス化される
# y = Gizmo() * 10

# しかし、代入の右辺が評価されている間に例外が発生したため、変数yは作成されない
print(dir())

"""
変数は単なるラベルなので、オブジェクトに複数のラベルが割り当てられても何の支障もない
これがエイリアス
"""

# 例8-3 同じオブジェクトの参照
charles = {'name': 'Charles', 'born': 1832}

# lewisはcharlesのエイリアス
lewis = charles

print(lewis is charles)
# True

# is演算子と関数idから確認できる
print(id(charles), id(lewis))
# 139713721683840 139713721683840

# lewisに要素を追加するのはcharlesに要素を追加するのと同じこと
lewis['balance'] = 950
print(charles)

# 例8-4 比較の結果
# alexはcharlesに割り当てられたオブジェクトと同じ中身を参照しています
alex = {'name': 'Charles', 'born': 1832, 'balance': 950}

# dictクラスの__eq__の実装はこれらのオブジェクトを比較して等価と判定する
print(alex == charles)
# True

# しかし、これらは単なるオブジェクト
# a is not b と比較するのがpythonの書き方
print(alex is not charles)
# True

"""
例8-3はエイリアスの一例
lewisとcharlesという２つの変数は同じオブジェクトにバインドされているエイリアスである
一方、alexとcharlesはエイリアスではない
これらの変数はそれぞれ異なるオブジェクトにバインドされている
バインドされているオブジェクトは同じ値をもつが、同一ではない

Python言語リファレンスより(3.1 Objective values and types)
すべてのオブジェクトにはID(識別子)、型、値があります
一度生成されたオブジェクトのIDが変わることはありません。
オブジェクトのメモリ内でのアドレスと考えても良い
is演算子は２つのオブジェクトの同一性を評価する
関数id()はオブジェクトを識別するIDを整数値で返す

オブジェクトIDが示すものは実装依存である
IDは数値で記述された一意なラベルであることが保証されており、
オブジェクトが存在する間に変化することはないという点
"""

# 例8-5 t1とt2は最初の時点だと等価だと評価されるが、タプルt1にある可変な要素を変更するとそうではなくなる

# t1は不変、t1[-1]は可変
t1 = (1, 2, [30, 40])
# t1と等価な要素を持つタプルt2#
t2 = (1, 2, [30, 40])

# 異なるオブジェクトであってもt1とt2は等価と評価される
print(t1 == t2)
# True

# t1[-1]のリストのIDを確認する
print(id(t1[-1]))
# 140709256520000

# t1[-1]のリストをインプレイスで変更する
t1[-1].append(99)

print(t1)
# (1, 2, [30, 40, 99])

# t1[-1]のIDに変化はないが、その値は変わっている
print(t1[-1])
# [30, 40, 99]

# t1とt2は等価でないと評価される
print(t1 == t2)
# False

# デフォルトのコピーは浅い
"""
コンストラクタや[:]を用いると浅いコピーが作られる
浅いコピーでは一番外側のコンテナはコピーされるが、
もとのコンテナに収容されている要素に対する参照と同じ参照で埋められる
"""

l1 = [3, [55, 44], (7, 8, 9)]

# list(l1)でl1のコピーを作る
l2 = list(l1)

print(l2)
# [3, [55, 44], (7, 8, 9)]

# コピーは等価
print(l2 == l1)
# True

# 参照しているオブジェクトは異なる
print(l2 is l1)
# False

# 例8-6 別のリストが要素として収容されているリストの浅いコピーを作成する
l1 = [3, [66, 55, 44], (7,  8, 9)]

# l2はl1の浅いコピー
l2 = list(l1)

# l1に100を追加してもl2には影響しない
l1.append(100)

# l1の要素であるl1[1]の要素の55を削除する
# l2[1]とl1[1]は同じリストにバインドされているため、この操作はl2にも影響を与える
l1[1].remove(55)

print('l1:', l1)
# l1: [3, [66, 44], (7, 8, 9), 100]

print('l2:', l2)
# l1: [3, [66, 44], (7, 8, 9)]

# l2[1]に参照されるリストのように可変オブジェクトの場合、
# +=演算子はリストをインプレイスで変更する
# l1[1]はl2[1]のエイリアスなので、この変更はl1[1]でも確認できる
l2[1] += [33, 22]

# タプルに対して+=を行うと新しいタプルを生成する
# ここではその結果が変数l2[2]を再バインドする　これはl2 = l2[2] + (10, 11)と同じ操作になる
# l1とl2の最後の位置にあるオブジェクトは同じオブジェクトでなくなる
l2[2] += (10, 11)

print('l1:', l1)
# l1: [3, [66, 44, 33, 22], (7, 8, 9), 100]

print('l2:', l2)
# l2: [3, [66, 44, 33, 22], (7, 8, 9, 10, 11)]

# 深いコピーはbus.pyを参照


# 参照として関数の引数

"""
Pythonが引数を受け渡す方法は共有渡し
共有渡しでは、関数のすべての引数の参照のコピーが
仮引数に引き渡される。
"""

# 例:8-11 関数は受け取った引数が可変オブジェクトなら変更できる

def f(a, b):
    a += b
    return a

x = 1
y = 2

# 数値xは変更されない
print(f(x, y))
# 3

print(x, y)
# 1 2

a = [1, 2]
b = [3, 4]

print(f(a, b))
# [1, 2, 3, 4]

# リストaは変更される
print(a, b)
# [1, 2, 3, 4] [3, 4]

t = (10, 20)
u = (30, 40)

# タプルtは変更される
print(f(t, u))
# (10, 20, 30, 40)

print(t, u)
# (10, 20) (30, 40)

# 引数のデフォルト値に可変型を使うのは考えもの
# haunted_bus.pyを参照

# 可変な引数を使うプログラムを頑強に
# twilight_bus.pyを参照